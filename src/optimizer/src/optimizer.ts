import type { Manifest, TransformedOutput } from '.';
import { getTransformedEntryPaths } from './entry-paths';
import { generateManifest, serializeManifest } from './manifest';
import { transformCode, transformCodeSync, transform, transformSync } from './transform';
import type { TransformCodeOptions, TransformFileOptions } from './types';

const SourceEntryPaths = Symbol('SourceEntryPaths');
const TransformedOutputs = Symbol('TransformedOutputs');
const OutputSymbols = Symbol('OutputSymbols');

export class Optimizer {
  private [SourceEntryPaths] = new Set<string>();
  private [TransformedOutputs]: Map<string, TransformedOutput>;
  private [OutputSymbols]: Map<string, string[]>;

  /**
   * Transforms the input code string, does not access the file system.
   */
  async transformCode(opts: TransformCodeOptions) {
    const result = await transformCode(opts);

    result.output.forEach((output) => {
      this[TransformedOutputs].set(output.outFile, output);
    });

    return result;
  }

  /**
   * Transforms the input code string, does not access the file system.
   */
  transformCodeSync(opts: TransformCodeOptions) {
    const result = transformCodeSync(opts);

    result.output.forEach((output) => {
      this[TransformedOutputs].set(output.outFile, output);
    });

    return result;
  }

  /**
   * Transforms the file read from the file system.
   */
  async transform(opts: TransformFileOptions) {
    const result = await transform(opts);

    result.output.forEach((output) => {
      this[TransformedOutputs].set(output.outFile, output);
    });

    return result;
  }

  /**
   * Transforms the file read from the file system.
   */
  transformSync(opts: TransformFileOptions) {
    const result = transformSync(opts);

    result.output.forEach((output) => {
      this[TransformedOutputs].set(output.outFile, output);
    });

    return result;
  }

  /**
   * Add an entry path defined by the user.
   */
  addSourceEntryPath(path: string) {
    if (typeof path === 'string') {
      this[SourceEntryPaths].add(path);
    }
  }

  /**
   * Get the entry paths generated by the optimizer.
   */
  getTransformedEntryPaths(manifest?: Manifest) {
    return getTransformedEntryPaths(this[TransformedOutputs], manifest);
  }

  getTransformedModule(path: string) {
    return this[TransformedOutputs].get(path);
  }

  hasTransformedModule(path: string) {
    return this[TransformedOutputs].has(path);
  }

  clearOutputSymbols() {
    this[OutputSymbols].clear();
  }

  setOutputSymbols(path: string, symbols: string[]) {
    if (typeof path === 'string') {
      if (Array.isArray(symbols)) {
        symbols = [...symbols];
      } else {
        symbols = [];
      }
      this[OutputSymbols].set(path, symbols);
    }
  }

  generateManifest() {
    return generateManifest(this[OutputSymbols]);
  }

  serializeManifest() {
    return serializeManifest(this.generateManifest());
  }

  clearModules() {
    this[SourceEntryPaths].clear();
    this[TransformedOutputs].clear();
  }
}
