---
title: Think Qwik
contributors:
  - manucorporat
  - hayley
  - adamdbradley
---

# 构想Qwik

从外观或功能上看，Qwik与其他web框架非常相似的。
也是通过渲染一个组件树的方式来实现一个可交互的应用。

但是Qwik和其他web框架不同的地方是：Qwik是怎么实现的。
Qwik的目标是瞬间启动应用，即使在移动设备上。
Qwik通过下面两个主要策略实现这一点：

1. 尽可能的延迟下载和执行JS代码。
2. 在服务端序列化应用和状态的执行状态，从而在客户端恢复执行。

Qwik是目标是 只需要下载和执行应用最小限度的代码。

## 核心原则

> 尽可能的延迟下载和执行JS代码

Qwik应用启动的很快是因为只有一小撮JS代码执行了。（最简单时，一个Qwik应用只需要下载1KB大小的JS即可变的可交互）

通过渐进式延迟加载JS的下载和执行，Qwik可以提供接近瞬时的启动性能，这是当前同类框架所不能的达到的。

Qwik很快不是因为它有什么聪明的算法，而是因为它认为大多数JS代码最终也不需要下载和执行，所以只下载和执行必要的JS就行了。
它的速度来自于（它的设计让它可以）少做很多事（比如hydration），而这些事是其他框框必须要做的（所以他们慢）。

## 可恢复性（Resumability） & 序列化

关于可恢复性的讨论在这里[here](../concepts/resumable/index.mdx)。
可恢复性让Qwik应用在服务端渲染完毕以后，在客户端继续执行。
所有框架都需要跟踪关于应用状态的一些内部数据结构。
当前的一批框架不会在服务端保存这些信息然后将其发送到浏览器，这带来的结果是，框架数据结构需要在浏览器上重建。
重建数据结构和给DOM添加事件的过程叫做hydration。

Qwik就不一样了，Qwik在服务端将工作交手给浏览器时，会序列化事件监听器、内部数据结构、以及应用状态到HTML里面。
因为所有信息都在HTML里序列化好了，浏览器就可以继续执行应用了（可恢复性）。


## 现代应用的问题在哪里?

现代应用或站点需要太多JS才能变得可交互。
太多JS会带来两个问题：

1. **网络贷款**: 许多JS代码要下载到客户端，在弱网环境下，这可能需要很长一段时间。
2. **启动时间**: 下载到客户端以后, 代码还需要执行 (hydration的一部分过程) 来使得站点变得可交互。

随着应用的交互越来越多、应用越来越复杂，这些年JS代码数量持续增加且没有减小的趋势。
简单来说，我们的站点越来越复杂，而随着复杂性的增加，就需要写更多的代码，而所有这些新增代码，
都会拉低站点的启动性能。

更糟糕的是，JS是单线程的，因此我们的复杂站点并不能充分利用多核CPU的优势。

### 我们是怎么一步步走到这里的?

上面两个问题的解决方案是非常明显的，但也是非常难的：减少JS数量。
说明显是因为我们都同意网站的JS越少，网站性能越好。
说难是因为我们的工具不支持让我们减少JS。
几乎所有我们的工具都在解决问题，但与此同时带来更多的JS代码。
这是因为大多数工具大多数工具都是用来解决特定问题的，并没有考虑它（工具）自身也会使网站JS代码量越来越多这件事。

你需要解决渲染、样式、动画、A/B测试、数据分析问题吗？
都有对应的工具给你准备好了。你只需要引入一个`<script>`标签，这些工具就能帮你解决特定的问题，但是代价是你的站点的初始bundle更大了。

作为一个产业，我们未能仔细考量bundle size的问题。
每个工具都在单独地解决特定问题，但是bundle size并没有放在天平的另一边进行衡量。
只有当你把越来越多的工具堆积在一个应用里，bundle size的问题才突然显现出来，但此时，已经很少有开发者能为此做什么了。

### 怎么解决?

Qwik从设计之初就着眼于解决疯涨的bundle size问题。
小的bundle size是Qwik的初始目标（初心），其他的设计决策都要首先屈从于此目标。

但Qwik也不一个能减少你JS代码量的框框。
它的方式是不需要在应用启动时，把应用的全部JS代码都一次性地下载到客户端。
Qwik是把"尽可能延迟加载和执行JS"理念发挥到极致的产物。

是的，QWIK需要一个不同方式来思考和设计你的应用。
结果是：几乎为0的初始JS量 和 当用户交互时渐进加载和执行其他JS代码。

### Size should not be a developer problem

Today, size is the developers' problem. If you follow best practices for each of the frameworks, tools, etc., you will have a large bundle size. It is at that time when developers start to mitigate the problem with some sort of lazy loading boundaries etc. (But as anyone who has tried will tell you, the options are limited.)

Our industry best practices lead to large bundles, and the web is full of examples.

The mantra of Qwik is that bundle size should not be something that developers should think about. It should just naturally emerge as part of how the framework is designed.

Qwik is designed from the ground up to produce lots of lazy loadable boundaries. Tooling can break up your application into many lazy-loadable chunks, and the runtime can download them only when needed.

### Why not fix existing frameworks/tools?

In short, the lazy loading philosophy is at a low level and can not be retroactively added to the existing frameworks/tools without changing them fundamentally. Such fundamental change would be incompatible with the framework/tools and their respective ecosystems, rendering them useless.

When a framework makes certain assumptions, such as that all rendering is synchronous, adding asynchronous lazy loading becomes pretty close to impossible. Or, if a framework recovers the listener location from templates, then download and execution of those templates is a must before the site can be interactive. These are just some of the more obvious examples, but in practice, there is a long tail of endless reasons why the current mental model does not fit the requirements of resumability.

The above also means that it is not feasible for existing frameworks to add resumability as a feature. Existing frameworks will never be able to do what Qwik can (without breaking backward compatibility).

### Why are we building Qwik?

Because we believe there is a better way to build sites. A way that does not involve massive amounts of JavaScript that must be downloaded eagerly on startup before your site becomes interactive. A way that allows the developer to think about adding features rather than how to break up the huge codebase into smaller chunks. A way to have instant-on sites for a better user experience. And all of that, in a way that is independent of the size of the application codebase.
