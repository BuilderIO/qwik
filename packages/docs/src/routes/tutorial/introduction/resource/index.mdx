---
title: Basics - Qwik Tutorial
contributors:
  - adamdbradley
  - manucorporat
  - iburzynski
---

For this tutorial, we would like to fetch the list of repositories for a given GitHub organization. To aid you, we have added the `getRepositories()` function to the bottom of the file. Your task is to use this function to fetch the list of repositories whenever the user updates the `org` input.

Qwik provides `useResource$()` and `<Resource>` to help you fetch and render data from a server. 

## Fetching data with `useResource$()`

Use `useResource$()` to set up how the data is fetched from the server.

```jsx
  const reposResource = useResource$<string[]>(({ track, cleanup }) => {
    // We need a way to re-run fetching data whenever the `github.org` changes.
    // Use `track` to trigger re-running of this data fetching function.
    track(github, 'org');

    // A good practice is to use `AbortController` to abort the fetching of data if a
    // new request comes in. We create a new `AbortController` and register a `cleanup`
    // function which is called when this function re-runs.
    const controller = new AbortController();
    cleanup(() => controller.abort());

    // Fetch the data and return the promise.
    return getRepositories(github.org, controller);
  });
```
### `track()` and `cleanup()`
The `useResource$()` function allows you to `track` values so it can be reactive to changes. `track()` can be called multiple times to track multiple values.

The `cleanup` function allows you to register code that releases resources from the previous run. It can be called multiple times to release multiple resources.

### `ResourceReturn`
`useResource$()` returns a `ResourceReturn` object: a fully reactive Promise-like object that can be serialized by Qwik. The object's `state` property can be one of three possible strings:

- `'pending'`: the data is not yet available
- `'resolved'`: the data is available
- `'rejected'`: the data is not available due to an error or timeout

## Rendering data with `<Resource>`

Use `<Resource>` to render the data returned by `useResource$()`. 

```jsx
  <Resource
     value={resourceToRender}>
     onPending={() => <div>Loading...</div>}
     onRejected={(reason) => <div>Error: {reason}</div>}
     onResolved={(data) => <div>{data}</div>}
  />
```

The `<Resource>` allows you to render different content depending on the resource's `state`:
- `onPending`: render a loading indicator
- `onResolved`: render the data
- `onRejected`: render the error

### SSR vs Client

The same code can render on both server and client, with slightly different behavior.

On the server, the `<Resource>` does not render `pending` state; instead, it pauses rendering until the resource is resolved and will always render as either `resolved` or `rejected`. 

On the client, the `<Resource>` renders all states, including `pending`.
