---
title: Qwik City - loader$()
contributors:
  - manucorporat
---

# `loader$()`

> Before learning about loaders, it's important **how the layouts and middleware system works in Qwik**, please check the [Layouts](/guide/layouts) guide first.

Loaders are used to **provide server-side data to the Qwik Components during rendering**, ie, Qwik Loaders should be always understood in the context of executing code in the server that is later consumed by a Qwik Component, if you want to create a RESTful endpoint, please check the [endpoints](/guide/endpoints) guide instead.

Loaders execute before Qwik renders the page, ie, as soon as the HTTP request is received, achiving low latency responses.

**Server loaders are created using the `loader$()` function**, and used directly inside a Qwik Component with the `use()` method, which returns a fully reactive signal.

**File: `src/routes/index.tsx`**
```tsx
import { loader$ } from '@builder.io/qwik-city';
import { component$ } from '@builder.io/qwik';

export const getServerTime = loader$(() => {
  return {
    time: Date.now();
  }
});

export default component$(() => {
  // Retrieve a reactive signal of the loader data
  const signal = getServerTime.use();
  return (
    <div>
      Server time: {signal.value.time}
    </div>
  );
});
```

> The `.use()` retrives the loader data, but it does not execute the loader. Loaders execute eagarly at the beginning of the request. For this reason they are only allowed in the `src/routes` folder, in a `layout.tsx` or `index.tsx` file, and they MUST be exported in the same module. Check the [Rules](#rules) section for more details.


## Multiple loaders

Multiple loaders are allowed across the whole application, and they can be used in any Qwik Component. **You can even declare multiple loaders in the same file**.

**File: `src/routes/layout.tsx`**
```tsx
import { component$ } from '@builder.io/qwik';
import { loader$ } from '@builder.io/qwik-city';
import { Footer } from '../components/footer.tsx';

export const getServerTime = loader$(() => {
  return {
    time: Date.now();
  }
});

export default component$(() => {
  const signal = getServerTime.use();
  return (
    <main>
      <Slot>
      <Footer />
    </main>
  );
});
```

**File: `src/components/footer.tsx`**
```tsx
import { component$ } from '@builder.io/qwik';

// Import the loader from the layout
import { getServerTime } from '../routes/layout.tsx';

export const Footer = component$(() => {
  // Consume the loader data
  const signal = getServerTime.use();
  return (
    <footer>
      Server time: {signal.value.time}
    </footer>
  );
});
```

**File: `src/routes/admin/index.tsx`**
```tsx
import { component$ } from '@builder.io/qwik';
import { loader$ } from '@builder.io/qwik-city';

export const isLogged = loader$(({cookies}) => {
  return {
    logged: checkCookies(cookies);
  }
});

export const getCurrentUser = loader$(({cookies}) => {
  return {
    user: currentUserFromCookies(cookies);
  }
});

export default component$(() => {
  const logged = isLogged.use();
  const user = getCurrentUser.use();
  return (
    <section>
      <h1>Admin</h1>
      {logged.value.logged ? (
        <p>Welcome {user.value.user.name}</p>
      ) : (
        <p>You are not logged in</p>
      )}
    </section>
  );
});
```

## Loader context

Just like endpoints such as `onGet()`, actions receive a context object with information about the current request. This information comes handly when the loaders needs to conditionally return data based on the request, or it needs to override the response status, headers or body manually.

```tsx
export const getServerTime = loader$((ev) => {
  console.log('Request headers:', ev.headers);
  console.log('Request cookies:', ev.cookies);
  console.log('Request url:', ev.url);
  console.log('Request method:', ev.method);
  console.log('Request params:', ev.params);

  return {
    time: Date.now();
  }
});
```

It's also possible to manually return some HTTP body instead of Qwik render, this happens when the loader writes directly to the body using the methods: `redirect()`, `json()`, `text()`, `html()`, `send()`.

When this happens, QwikCity will not render the Qwik Component.

```ts
export const getServerTime = loader$((ev) => {
  // If URL query contains `format=json`, return a JSON response
  if (query.get('format') === 'json') {
    throw ev.json(200, {
      time: Date.now();
    });
  }
  // If URL query contains `format=text`, return a text response
  if (query.get('format') === 'text') {
    throw ev.text(200, `The time is: ${Date.now()}`);
  }

  // Otherwise returns data to be used in the Qwik Component
  return {
    time: Date.now();
  }
});
```


## Rules

Loaders can only be declared inside the `src/routes` folder, in a `layout.tsx` or `index.tsx` file, and they MUST be exported in the same module.

- `loader$()` can only be used inside the `layout` and `index` files, inside the `src/routes` folder.
- `loader$()` function must return a JSON serializable value.

```tsx
// File: src/routes/layout.tsx
import { loader$ } from '@builder.io/qwik';

// ❌, Date is not JSON serializable
const getTime = loader$(() => {
  return {
    time: new Date()
  }
});

// ✅, the getTime loader is exported
export const getTime = loader$(() => {
  return {
    time: (new Date()).toISOString()
});
```

- `loader$()` MUST be exported in the same module.
```tsx
// File: src/routes/layout.tsx
import { loader$ } from '@builder.io/qwik';

// ❌, it needs to be exported
const getTime = loader$(() => {
  return Date.now();
});

// ✅, the getTime loader is exported
export const getTime = loader$(() => {
  return Date.now();
});
```


## When to use a loader?

A loader should be used when you need to provide some server-side data to your Qwik Components. For example, if you need to fetch some data from a database or an API, you can use a loader to do that.

You should not use a loader to create a REST API, for that you better use a [Endpoint](/qwik-city/), which allows you to have tight control over the response headers and body.
