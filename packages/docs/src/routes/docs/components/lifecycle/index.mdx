---
title: Lifecycles
keywords: useEffect, hooks
contributors:
  - nnelgxorz
  - RATIU5
  - manucorporat
---

import diagram from './diagram2.svg';

# Lifecycles

[Resumability](/docs/concepts/resumable/index.mdx) plays a key role to understand how lifecycle hooks work in Qwik.

Usually **the life of a component starts on the server** (during SSR or SSG), in that case the hooks will run like this:

```
  useMount$ -> useTask$ -> useResource$ -> RENDER -> useClientEffect$
                                                   |
|--------------------- SERVER ---------------------|----- BROWSER -----|
                                                   |
                                              pause|resume
```

> **Notice** that because the component was mounted in the server, **only useClientEffect$() runs in the browser**. This is because the browser continues the same lifecycle, that was paused in the server and resumed in the browser.

What if a **component is first rendered/mounted in the browser**? In that case the hooks will run like this:

```
  useMount$ -> useTask$ -> useResource$ -> RENDER -> useClientEffect$

|------------------------------- BROWSER ------------------------------|
```

> **Notice** that the lifecycle looks exactly the same, but this time all the hooks run in the browser, and non in the server.

For now, we know that mounting happens exactly once across all platforms, this is a core difference between Qwik and other frameworks, were the lifecycle is repeated, and components are mounted during SSR and during hydration.

## `useMount$()`

- **When:** BEFORE component's first render
- **Times:** exactly once
- **Platform:** server and browser

`useMount$()` registers a hook to be executed upon component creation, while `useMount$()` can execute on either the server or on the client, it runs exactly once. (Either on the server or on the client, depending on where the component got first rendered).

`useMount$()` will block the rendering of the component until after the async callback resolves. (This is useful for fetching asynchronous data and delaying rendering until data is received, ensuring that the rendered component contains the data)

### Example

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    users: [],
  });
  useMount$(async () => {
    // This code will run on component creation to fetch the data.
    store.users = await db.requestUsers();
  });
  return (
    <>
      {store.users.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});

interface User {
  name: string;
}

export function User(props: { user: User }) {
  return <div>Name: {props.user.name}</div>;
}
```

### Server/Client only mount

Qwik does not provide a specific hook to run code only on the server or only on the client during mount. However, you can use `@builder.io/qwik/build` conditionals to achieve this:

```tsx
import { isServer, isBrowser } from '@builder.io/qwik/build';

export const Cmp = component$(() => {
  const store = useStore({
    users: [],
  });
  useMount$(async () => {
    if (isServer) {
      // If the component is mounted on the server, call DB directly.
      store.users = await db.requestUsers();
    }
    if (isBrowser) {
      // If the component is mounted on the browser, fetch users through API.
      store.users = await fetchGetUser();
    }
  });

  return (
    <>
      {store.users.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});
```

### When to use `useMount$()`

You wanna run some code ONLY when the component mounts, once.

## `useTask$()`

- **When:** BEFORE component's first render and when tracked state changes
- **Times:** at least once
- **Platform:** server and browser

Just like `useMount$()`, the hook is called the first time when the component mounts, however it can be called multiple times if (and only if) it tracks a [signal or store](/docs/components/state/index.mdx) for changes.

> `useTask$()` is different from React's useEffect in that, `useWatch` also runs during SSR and before rendering.

### Example

The `useTask$()` function is used to observe the `state.count` property. Any changes to the `state.count` cause the `watchFn` to execute which in turn updates the `state.doubleCount` to the double of `state.count`.

```tsx
import { component$, useStore, useTask$ } from '@builder.io/qwik';

export const Cmp = component$(() => {
  const store = useStore({
    count: 1,
    doubleCount: 0,
  });

  useTask$(({ track }) => {
    const count = track(() => store.count);
    store.doubleCount = 2 * count;
  });

  return (
    <div>
      {store.count} / {store.doubleCount}
    </div>
  );
});
```

The example above uses the `track` function to watch changes in `() => store.count`. The callback will run once in the SSR when the component is mounted and every time `store.count` changes.

> Notice that `useTask$()` runs **BEFORE** the actual rendering and in the server, thus manual DOM manipulation must be done with caution.

> See also the `useClientEffect$()` hook that shares similar semantics but only runs on the client after rendering.

### When to use `useTask$()`

You wanna mutate some state, or perform some action when some state changes. i.e, you need to have some side effects.

> Note, if you wanna load some data (for example a fetch()), to later use that in your component, look at [`useResource$()`](/docs/components/resource/index.mdx). This API will be even more efficiently leveraging SSR streaming and parallelisim.

## `useClientEffect$()`

- **When:** AFTER component's first render and on tracked state changes
- **Times:** at least once
- **Platform:** browser only

Similarly to `useTask$()` or `useMount$()` this hook will also run at least once, but it will never RUN in the server, that is, it will run only in the browser.

For all components that got mounted during SSR (in the server), the `useClientEffect$()` will run eagarly, that means, without user interaction, but the eagerness can be configured!

```tsx
useClientEffect$(() => console.log('runs in the browser'), {
  eagerness: 'visible', // 'load' | 'visible' | 'idle'
});
```

This is a unique feature of Qwik, any other frameworks would execute this and other code as part of hydration, but in Qwik, we can even specify when it happens:

- `"visible"`: when the component becomes visible in the viewport (uses [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) under the hood). This is the default value.
- `"load"`: when the documents finish loading (the document's "load" event)
- `"idle"`: after load the first moment the site becomes idle. It uses [`requestIdleCallback()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback) under the hood.

Like `useWatch`

### Example

```tsx
export const Timer = component$(() => {
  const store = useStore({
    count: 0,
  });
  useClientEffect$(() => {
    // Only runs in the client
    const timer = setInterval(() => {
      store.count++;
    }, 500);
    return () => {
      clearInterval(timer);
    };
  });
  return <>{store.count}</>;
});
```

> **NOTE:** Don't abuse `useClientEffect$()` when the same logic can be achieved using `useTask$()` or other means. Ask to yourself: Does this code really need to run at the beginning in the browser? If the answer is no, `useClientEffect$()` is probably not the right answer.

> How does it compare with React's `useEffect()`? Both APIs share a lot of semantics, but while both run AFTER rendering,`useClientEffect$()` can run also independently from rendering.

### When to use `useClientEffect$()`

You need to run JS right at loading time of the page, even if the user never interacts with the page.

- Initialize some animations
- WebGL logic
- Read some `localStorage`
- Runs some code without user interaction

## Diagram flow

<img src={diagram} />

## Use Method Rules

When using lifecycle hooks, you must adhere to the following rules:

- They can only be called in `component$`
- They can only be called at the root level of a function / arrow function context, not inside of branches or conditional blocks
- They can only be called from another `use*$` method, allowing for composition

```tsx
useHook(); // <-- ❌ does not work

export default component$(() => {
  useCustomHook(); // <-- ✅ does work
  if (condition) {
    useHook(); // <-- ❌ does not work
  }
  const myQrl = $(() => useHook()); // <-- ❌ does not work
  return <button onClick$={() => useHook()}></button>; // <-- ❌ does not work
});

const useCustomHook = () => {
  useHook(); // <-- ✅ does work
};
```
