---
title: Overview
contributors:
  - hamatoyogi
  - shairez
  - RATIU5
  - leifermendez
  - manucorporat
  - adamdbradley
  - fleish80
---

# Components

Components are the basic building blocks of Qwik Applications. 
They are created using [JSX](https://reactjs.org/docs/introducing-jsx.html) 
and are very similar to other frameworks' components.


## `component$()`

Here's an example of a simple component: 

```tsx
import { component$ } from '@builder.io/qwik';

export const MyCmp = component$(() => {
  return <p>Hello, world!</p>
});

```

A component is a small, reusable piece of code that can be used to build your user interface (UI).


> ### But what's the deal with this $ sign?
>
> Qwik's super powers come from its ability to automatically split the application to tiny chunks that will later be streamed to the user. 
> The $ sign in the end of most of Qwik's API helps its optimizer (compiler) to know where to split the code.
> To learn more [please visit the optimizer doc]()



## Props

Props (or properties) are used to pass data into a component. Props are declared as named arguments of the component.

In this example a component `Item` declares optional `name`, `quantity`, `description`, and `price`.

```tsx
interface ItemProps {
   description?: string;
   price?: number;
}

export const Item = component$((props: ItemProps) => {
  return <div>
    <h2>{props.description}</h2>
    <p>{props.price}</p>
  </div>;
});
```

> ðŸ’¡ as you see above, in JSX, you can render variables using the `{ varName }` syntax
> trace in the browser HTML tree.



## Nesting components

Qwik components can be nested in other components and you can pass props to them.

```tsx
export const MyApp = component$(() => {
  return (
    <div>
      This is a counter:
      
      <Counter step={1} />
    </div>
  );
});

interface CounterProps {
   step?: number;
}

export const Counter = component$((props: CounterProps) => {
  return <span>
    {props.step}
  </span>
});

```


## Fragments

In JSX, you can only have one root element.
In order to prevent adding unnecessary divs, we can use an "empty" element called a "fragment" with the empty tags `<>` and `</>` which replaces the need for a root element. 

These won't be visible in the rendered html of the component.


```tsx
import { component$ } from '@builder.io/qwik';

export const MyCmp = component$(() => {
  return <>Look ma! I'm a real html!</>
});

```

## Read more about components

TBD: link to docs that dive deeper on the component model



## API Overview

### State

- [`useStore(initialState)`](../state/index.mdx#usestore) - creates a reactive object that can be used to store state
- [`useSignal(initialState)`](../state/index.mdx#usesignal) - creates a reactive value
- [`createContext(contentName)`](../context/index.mdx#createcontext) - creates a context reference
- [`useContextProvider()`](../context/index.mdx#usecontextprovider) - provides a value to a given context
- [`useContext()`](../context/index.mdx#usecontext) - reads the value of the current context

### Styles

- [`useStylesScoped$()`](../styles/index.mdx#usestylesscoped) - appends scoped styles to the component
- [`useStyles$()`](../styles/index.mdx#usestyles) - appends unscoped styles to the component

### Events

- [`useOn()`](../events/index.mdx) - appends a listener to the current component programatically
- [`useOnWindow()`](../events/index.mdx) - appends a listener to the window object programatically
- [`useOnDocument()`](../events/index.mdx) - appends a listener to the document object programatically

### Lifecycles

- [`useTask$()`](../lifecycle/index.mdx) - defines a callback that will be called before render and/or when a watched store changes
- [`useResource$()`](../resource/index.mdx) - creates a resource to asyncronously load data
- [`useClientEffect$()`](../lifecycle/index.mdx#useclienteffect) - defines a callback that will be called after render in the client only (browser)

### Other

- [`$()`](../../advanced/qrl/index.mdx) - creates a QRL
- `noSerialize()`
- `useErrorBoundary()`

### Components

- [`<Slot>`](../projection/index.mdx) - declares a content projection slot
- `<SSRStreamBlock>` - declares a stream block
- `<SSRStream>` - declares a stream
- `<Fragment>` - declares a JSX fragment

## See Also

- [Lite components](../lite-components/index.mdx)
